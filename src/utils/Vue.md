#### Vue

  ##### 谈谈你对vue的理解

  Vue是一个渐进式JavaScript框架，它专注于构建用户界面。Vue的核心思想是数据驱动和组件化。通过将页面拆分成独立的组件，可以更好地管理代码，提高代码的复用性和可维护性。

  Vue的优势在于其简单易用、灵活性高、性能卓越和扩展性强。Vue的模板语法易于理解和学习，可以快速构建交互式的Web应用程序。同时，Vue的生命周期钩子和自定义指令等功能，使得Vue可以满足各种复杂的需求。另外，Vue还提供了Vuex、Vue Router等官方插件，可以进一步扩展Vue的功能。

  Vue的响应式数据绑定机制是Vue最核心的特性之一。通过对数据进行劫持和监听，可以实现数据的双向绑定，即数据变化会自动更新视图，同时视图的变化也会反映到数据上。这种机制使得Vue的数据流非常清晰和可预测，同时也减少了开发的工作量。

  总之，我认为Vue是一个优秀的JavaScript框架，它简单易用、功能强大、扩展性好，并且有着极佳的性能表现。对于前端开发人员来说，Vue是一个值得深入学习和使用的框架。

  ##### Vue的 nextTick 的原理

  nextTick的用法：在某些情况下，我们需要在 DOM 更新完成后执行一些操作，这时就需要使用 Vue.nextTick() 方法。

  Vue.nextTick() 方法的实现原理是基于浏览器的异步任务队列，采用微任务优先的方式。Vue.js 采用异步更新机制来提高渲染效率，当我们修改数据时，Vue.js 不会立即更新 DOM，而是将 DOM 更新操作放到一个异步队列中，等到下一次事件循环时再执行。这样做可以避免频繁的 DOM 操作，提高性能。而 Vue.nextTick() 方法则是将一个回调函数推入到异步任务队列中，等待 DOM 更新完成后执行。具体实现方式有以下几种：
  + 使用原生的 setTimeout 方法：在 Vue.js 2.x 中，如果浏览器支持 Promise，则会优先使用 Promise.then() 方法。如果不支持 Promise，则会使用原生的 setTimeout 方法模拟异步操作。
  + 使用 MutationObserver：如果浏览器支持 MutationObserver，Vue.js 会使用 MutationObserver 监听 DOM 更新，并在 DOM 更新完成后执行回调函数。
  + 使用 setImmediate：在 IE 中，setImmediate 方法可以用来延迟异步执行任务。在 Vue.js 2.x 中，如果浏览器支持 setImmediate，则会优先使用 setImmediate，否则会使用 setTimeout。

  **最后收敛：**
  总之，Vue.nextTick() 的实现原理是利用浏览器的异步任务队列，在 DOM 更新完成后执行回调函数。不同浏览器支持的异步任务方法不同，Vue.js 会根据浏览器的支持情况选择合适的异步任务方法。

  ##### vue 在渲染列表的时候，为什么不建议用数组的下标当做列表的key值

  主要是要**保证渲染列表的性能和正确性。**

  在Vue渲染列表时，每个元素需要一个唯一的key值来标识自己，这个key值后续在更新中会被用来判断列表中哪些元素需要更新、删除或新增。如果使用数组的下标作为key值，虽然可以满足每个元素key值唯一的需求，但是由于Vue的更新机制是基于diff算法实现的，如果将数组下标作为key值，那么当列表发生变化时，可能会导致key值发生改变，从而引发不必要的组件重新渲染，甚至会导致性能问题。例如，当删除列表中某个元素时，其后面的所有元素的下标都会发生改变，导致Vue重新渲染整个列表。为了避免这个问题，我们需要为每个元素提供一个稳定的、与其内容相关的唯一key值，例如使用元素的id属性作为key值。这样，当列表中某个元素的内容发生变化时，其对应的key值也会发生改变，从而告诉Vue需要更新该元素。

  ##### 谈一下对vuex的理解

  Vuex是一个专门为Vue.js开发的状态管理库，它提供了一个集中式的状态管理机制，用于管理Vue应用中的所有组件的共享状态。

  Vuex的核心概念包括：state、mutations、actions和getters。其中，state是应用的状态，而mutations用于修改state中的状态。actions则用于处理异步操作或批量的同步操作，最终通过mutations来改变state。getters则用于对state中的数据进行计算或过滤。在Vuex中，数据流的流向是单向的，即从state到组件，再从组件到mutations/actions。这种单向数据流的机制使得数据的流动更加清晰，同时也更容易进行调试和维护。

  总之，Vuex是Vue.js生态中的一个非常重要的插件，适用于中大型的Vue.js应用，它通过提供集中式的状态管理机制，帮助我们更好地管理数据流，提高应用的可维护性和可扩展性。

  ##### vue-router有哪几种导航钩子

  + **beforeEach:** 在每次路由跳转之前执行，可以用来进行用户身份验证、路由拦截等操作。
  + **afterEach:** 在每次路由跳转之后执行，可以用来进行路由跳转后的操作，比如页面滚动、统计PV等操作。
  + **beforeResolve:** 在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后执行。
  + **beforeRouteEnter:** 在进入路由之前执行，与全局beforeEach的区别是它可以针对某个具体路由进行设置。
  + **beforeRouteUpdate:** 在路由更新时执行，比如路由参数发生变化时，可用于获取当前路径，匹配激活菜单。
  + **beforeRouteLeave:** 在离开当前路由时执行，可以用来进行页面数据的保存或弹出提示等操作。

  ##### Vue-Router的原理

  Vue Router是Vue.js官方提供的一款路由管理器，它通过监听URL变化，匹配路由规则，展示对应的组件内容，从而实现单页应用的路由控制。

  Vue Router的核心原理包括以下几个方面（这玩意记不住就先说下面的总结收敛的，然后再回忆，相对低频）：
  + 路由匹配：Vue Router通过定义路由规则来匹配URL路径，并根据匹配结果展示对应的组件内容。路由规则可以使用路径、参数、查询参数等多种方式进行定义，同时支持嵌套路由和命名路由等高级特性。

  + 路由模式：Vue Router支持两种路由模式，分别是Hash模式和History模式。在Hash模式下，路由信息会被保存在URL的Hash部分，通过监听Hash变化来进行路由控制；在History模式下，路由信息会被保存在浏览器的History API中，通过修改浏览器历史记录来进行路由控制。

  + 路由导航：Vue Router中的导航钩子可以监听路由变化，进行路由拦截、身份验证等操作。导航钩子包括全局导航钩子和组件内导航钩子，可以在路由跳转前、跳转后、路由更新等不同阶段执行相应的逻辑。

  + 路由组件：Vue Router通过组件的动态加载来实现异步路由组件，可以根据需要动态加载路由组件，从而提高应用的性能和用户体验。同时，Vue Router还支持路由懒加载、路由元信息等高级特性，可以进一步提高应用的灵活性和可维护性。

  总的来说：Vue-Router通过路由匹配、路由模式、路由导航、路由组件等多个方面实现了完整的路由控制逻辑，为开发者提供了强大的路由控制能力

  ##### Vue Router history 模式为什么刷新出现404

  history模式，它利用了HTML5的 History API，比如pushState和replaceState。这些方法可以改变URL的路径部分而不会重新加载页面。比如```http://example.com/about```。但是当用户直接访问这个URL时，服务器需要返回正确的页面，否则会出现404错误。所以history模式需要服务器支持，把所有路由都指向同一个index.html。前端的话，当用户点击前进或后退按钮，会触发popstate事件，这时候Vue Router会根据当前路径加载对应的组件。如果是通过pushState导航的话，就需要手动处理路由的变化。

  ##### mounted生命周期和keep-alive中activated的优先级

  在 Vue 中，mounted 生命周期是指一个组件被挂载到 DOM 中后触发的钩子函数。而 keep-alive 是一个用来缓存组件的抽象组件，它自身没有任何展示效果，只是将内部包含的组件缓存起来，从而能够在需要时快速地切换到缓存的组件。

  当一个组件第一次被挂载时，mounted 生命周期会被触发，同时 keep-alive 中的缓存组件还没有被渲染，因此 activated 生命周期并不会被触发。只有当一个被缓存的组件被激活后（比如从其他页面返回到该组件所在的页面），activated 生命周期才会被触发。因此，优先级上 mounted 生命周期高于 activated 生命周期。

  ##### vue父子组件钩子的执行顺序是什么？

  在 Vue 中，父子组件之间的生命周期钩子执行顺序如下：
  1. 加载阶段

  2. 父组件 beforeCreate 钩子
  3. 父组件 created 钩子
  4. 父组件 beforeMount 钩子
  5. 子组件 beforeCreate 钩子
  6. 子组件 created 钩子
  7. 子组件 beforeMount 钩子
  8. 子组件 mounted 钩子
  9. 父组件 mounted 钩子

  10. 更新阶段
  11. 父组件 beforeUpdate 钩子
  12. 子组件 beforeUpdate 钩子
  13. 子组件 updated 钩子
  14. 父组件 updated 钩子

  15. 销毁阶段
  16. 父组件 beforeDestroy 钩子
  17. 子组件 beforeDestroy 钩子
  18. 子组件 destroyed 钩子
  19. 父组件 destroyed 钩子

  在这个过程中，子组件的生命周期钩子的执行顺序总是在父组件的生命周期钩子之后。在 keep-alive 组件中，由于缓存组件会被 keep-alive 管理，因此在组件被激活或停用时，执行的生命周期钩子会发生变化：

  1. 激活（activated）缓存中的组件时：
  2. 父组件 activated 钩子
  3. 子组件 activated 钩子
  4. 停用（deactivated）缓存中的组件时：
  5. 父组件 deactivated 钩子
  6. 子组件 deactivated 钩子
  
  ##### vue 父子组件传值有哪些方式

  Vue父子组件之间传递数据的方式有以下几种：

  **Props：** 通过向子组件传递属性的方式实现数据传递。在父组件中通过v-bind绑定子组件的属性，子组件中通过props接收父组件传递的数据。这是一种单向数据流的方式，父组件可以向子组件传递数据，但是子组件不能直接修改传递过来的数据，需要通过触发事件的方式通知父组件进行修改。

  **事件：** 父组件通过$emit方法触发子组件的自定义事件，子组件中通过$on监听事件并接收参数，从而实现数据的传递。这也是一种单向数据流的方式，父组件通过事件向子组件传递数据，子组件可以通过触发事件的方式通知父组件进行修改。

  **$parent/$children：** 通过访问父组件或子组件的实例属性来实现数据的传递。但是这种方式不够直观，且容易出现问题，因为父组件或子组件的实例属性可能会在不同的组件结构中发生变化。

  **$refs：** 通过在父组件中使用ref属性来获取子组件的实例，从而可以直接访问子组件的属性和方法。这种方式也不够直观，且容易出现问题，因为在组件结构复杂的情况下，$refs可能会变得混乱。

  其中，Props是最常用的一种方式，因为它不仅可以实现数据的传递，还可以进行数据类型检查和默认值设置，使得数据的传递更加稳定和安全。

  ##### Vue 中 v-if 和 v-for 能否同时使用？

  首先，这两者可以同时使用，但是在不同版本中会有不同的反应：

  Vue2版本中，因为```v-for```的优先级大于```v-if```,程序并不会报错，但是可能会出现性能问题。例如：两者一起使用的情况下，渲染函数中可以看出会先执行循环再判断条件，哪怕我们只渲染列表中一小部分元素，也得在每次重渲染的时候遍历整个列表，会严重浪费性能。通常官方不建议同时使用，或者是通过 **外层包裹** 或者**计算属性filter后再进行渲染**

  Vue3版本中，则```v-if```的优先级大于```v-for```,这就导致，如果 v-if 如果依赖某个列表中的元素的某个属性，而 v-if 判断的变量还不存在，就会导致报错。解决方案跟Vue2大致一样。

  ##### Vue 中 v-if 和 v-show 有什么不一样？

  v-if 和 v-show 在Vue中都是条件渲染，本质上都是为了控制元素是否显示在页面上。

  两者之间的区别：

  + 控制手段不同：
    + v-show 隐藏是为该元素添加 css--display:none，dom元素依旧还在；
    + v-if 显示隐藏是将 dom 元素整个添加或删除；

  + 编译过程不同：
    + v-show 只是简单的基于 CSS 切换；
    + v-if 切换有一个局部卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；

  + 编译条件不同：
    + v-if 是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。渲染条件为假时，并不做操作，直到为真才渲染。
    + v-show 由 false 变为 true 的时候不会触发组件的生命周期

  + 用法上的区别：
    + v-if 相比 v-show 开销更大的（直接操作dom节点增加与删除）
    + 如果需要非常频繁地切换，则使用 v-show 较好
    + 如果在运行时条件很少改变，则使用 v-if 较好
  
  ##### Vue 生命周期详解
  
  [![image.png](https://i.postimg.cc/9FWSm3Z5/image.png)](https://postimg.cc/rzPgjPfQ)

  **需要注意的点是：** 

  + 选项式和组合式两者用法上不一样，组合式API需要引入，再进行使用。

  + ```beforeCreate``` 和 ```created``` 在Vue3中已经不存在，```setup``` 贯穿了这两个周期。
  
  + ```mounted``` ```beforeUpdate``` ```update``` ```activated``` deactivated等几个生命周期函数，变成了```onmounted``` ```onbeforeUpdate``` ```onupdate``` ```onactivated```

  + ```beforeDestroy``` 和 ```destroyed``` 变成了 ```onbeforeUnmounted``` 和 ```onunmounted```

  + Vue3 还添加了两个开发过程可使用的调式生命周期函数
    + ```renderTracked``` :此钩子事件能够实现当组件渲染时，追踪到响应式依赖的调用。
    + ```renderTriggered``` :此钩子事件告诉你是什么操作触发了重新渲染，以及该操作的目标对象和键。

#### 如何理解 Vue 中的自定义指令


#### Vue 的数据双向绑定(v-model)原理？

**核心点：**
  1. 理解什么是 Vue 中的双向绑定，带来的好处是什么？
  2. 单向绑定和双向绑定的优缺点是什么？
  3. 理解 Vue 中，对于 input、checkbox、radio、自定义组件的双向绑定实现细节
  4. 能够回答出 v-model 和 sync 修饰符有什么区别

  **单向绑定和双向绑定的优缺点是什么？**

  + 单向绑定（One-Way Data Binding）
    + 数据流清晰可预测（一般都是model -> View），组件间解耦，依赖关系明确，适合大型项目，也便于后期的维护和测试。也是复杂应用实施状态管理的前提。
    + 因为是单向绑定，所以需要手动修改数据值，以保持数据的更新，开发效率不高。

  + 双向绑定（Two-Way Data Binding）
    + 适用于实时反应用户输入的场景，简化表单处理。适合小型项目或简单交互，强调开发效率（如后台管理等）。
    + 数据流不透明，因为是双向绑定的，自动同步可能导致数据变更来源模糊，尤其在复杂组件层级中，调试难度增加。

  **```v-model``` 和 ```.sync``` 修饰符的区别** 

  + Vue2 中的使用
    + ```v-model``` 为单个 prop 的双向绑定设计，是```:value="data" @input="data = $event.target.value"``` 的语法糖
    + ```:value.sync``` 支持多个 props 的双向绑定，解决 v-model 只能绑定单个值的限制。主要是实现子组件与父组件的双向绑定是 
    ```html
    <!-- 父组件 -->
    <ChildComponent :title.sync="pageTitle" :size.sync="pageSize" />

    <!-- 等价于 -->
    <ChildComponent 
      :title="pageTitle" 
      @update:title="pageTitle = $event"
      :size="pageSize"
      @update:size="pageSize = $event"
    />
    ```

  + Vue3 中取消了 ```.sync```修饰符，因为 ```v-model``` 可支持多个Prop绑定，因此可以使用 v-bind 和 v-on 来手动实现类似的双向数据绑定效果

  ```html
  <!-- 父组件 -->
  <ChildComponent v-model:title="pageTitle" v-model:size="pageSize" />

  <!-- 等价于 -->
  <ChildComponent
    :title="pageTitle"
    @update:title="pageTitle = $event"
    :size="pageSize"
    @update:size="pageSize = $event"
  />
  ```

#### 

  
















