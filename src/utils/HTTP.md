#### HTTP协议

  ##### 常见的HTTP请求头和响应头

  **HTTP Request Header:**
  + **Accept:** 浏览器能够处理的内容类型 (例如：```application/json, text/plain, */*```)
  + **Accept-Charset:** 浏览器能够显示的字符集 
  + **Accept-Encoding：**浏览器能够处理的压缩编码 (例如：```gzip, deflate, br, zstd```)
  + **Accept-Language：**浏览器当前设置的语言 (例如： ```zh-CN,zh;q=0.9```)
  + **Connection：**浏览器与服务器之间连接的类型
  + **Cookie：**当前页面设置的任何Cookie
  + **Host：**发出请求的页面所在的域
  + **Referer：**发出请求的页面的URL
  + **User-Agent：**浏览器的用户代理字符串
  [![image.png](https://i.postimg.cc/x1gsxyZh/image.png)](https://postimg.cc/CRBHdDSs)

  **HTTP Responses Header:**
  + **Date：**表示消息发送的时间，时间的描述格式由rfc822定义
  + **server:** 服务器名称
  + **Connection：**浏览器与服务器之间连接的类型
  + **Cache-Control：**控制HTTP缓存
  + **content-type:** 表示后面的文档属于什么MIME类型

  常见的 **```Content-Type```** 属性值有以下四种：

  1. application/x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。

  2. multipart/form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。

  3. application/json：服务器消息主体是序列化后的 JSON 字符串。

  4. text/xml：该种方式主要用来提交 XML 格式的数据。

  ##### HTTP状态码304是多好还是少好

  服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载。

  状态码304不应该认为是一种错误，而是对客户端有缓存情况下服务端的一种响应。

  **总的来说：**

  产生较多304状态码的原因：

  + 页面更新周期长或不更新=
  + 纯静态页面或强制生成静态html

  304状态码出现过多会造成以下问题：
  
  + 网站快照停止；
  + 收录减少；
  + 权重下降。

  ##### 常见的HTTP请求方法

  + **GET:** 向服务器获取数据；
  + **POST：** 将实体提交到指定的资源，通常会造成服务器资源的修改；
  + **PUT：** 上传文件，更新数据；
  + **DELETE：** 删除服务器上的对象；
  + **HEAD：** 获取报文首部，与GET相比，不返回报文主体部分；
  + **OPTIONS：** 询问支持的请求方法，用来跨域请求；
  + **CONNECT：** 要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信；
  + **TRACE:** 回显服务器收到的请求，主要⽤于测试或诊断。

  ##### OPTIONS请求方法及使用场景

  OPTIONS是除了GET和POST之外的其中一种 HTTP请求方法。

  OPTIONS方法是用于请求获得由 **```Request-URI```** 标识的资源，在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能。该请求方法的响应不能缓存。

  OPTIONS请求方法的**主要用途**有两个：
  + 获取服务器支持的所有HTTP请求方法；
  + 用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。

  ##### HTTP 1.0 和 HTTP 1.1 之间有哪些区别？

  + **连接方面**，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。
  + **资源请求方面**，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
  + **缓存方面**，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。
  + http1.1 中新增了 **host** 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。
  + http1.1 相对于 http1.0 还新增了很多**请求方法**，如 PUT、HEAD、OPTIONS 

  ##### HTTP 1.1 和 HTTP 2.0 的区别

  + **二进制协议：** HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。
  + **多路复用：** HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了"队头堵塞"【1】的问题。
  + **数据流：** HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。
  + **头信息压缩：** HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。
  + **服务器推送：** HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。

  ##### HTTP和HTTPS协议的区别

  HTTP和HTTPS协议的主要区别如下：

  + HTTPS协议需要CA证书，费用较高；而HTTP协议不需要；
  + HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；
  + 使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；
  + HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。

  ##### GET方法URL长度限制的原因

  实际上**HTTP协议规范**并没有对get方法请求的url长度进行限制，这个限制是**特定的浏览器及服务器对它的限制**。IE对URL长度的限制是2083字节(2K+35)。由于IE浏览器对URL长度的允许值是最小的，所以开发过程中，只要URL不超过2083字节，那么在所有浏览器中工作都不会有问题。

  ##### 当在浏览器中输入 Google.com 并且按下回车之后发生了什么？

  + **解析URL：** 首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。

  + **缓存判断：** 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。

  + **DNS解析：** 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。

  + **获取MAC地址：** 当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。

  + **TCP三次握手：** 下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 **SYN** 连接请求报文段和一个随机序号，服务端接收到请求后，向客户端发送一个 **SYN ACK** 报文段，确认连接请求，并且携带发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。

  + **HTTPS握手：** 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。

  + **返回数据：** 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。

  + **页面渲染：** 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。

  + **TCP四次挥手：** 最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。

  ##### 对keep-alive的理解

  HTTP的 **```Keep-Alive```**（持久连接）是一种优化技术，允许在单个TCP连接上发送和接收多个HTTP请求/响应，而不是为每个请求单独建立和断开连接。这是HTTP/1.1默认支持的机制，旨在提升性能并减少资源消耗。

  + **HTTP1.0** 版本是默认没有Keep-alive的（也就是默认会发送keep-alive），所以要想连接得到保持，必须手动配置发送```Connection: keep-alive```字段。若想断开keep-alive连接，需发送 ```Connection:close``` 字段；
  + **HTTP1.1** 规定了默认保持长连接，数据传输完成了保持TCP连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送```Connection：close```首部字段。

  **优点：**
  + 减少延迟：复用TCP连接避免了重复的握手/挥手，显著降低延迟（尤其对高延迟网络或小型资源请求）。
  + 提升吞吐量：单个连接处理多个请求，减少了TCP连接数，降低服务器压力（如文件描述符、内存占用）。
  + 支持管道化（Pipelining）：在HTTP/1.1中，Keep-Alive允许客户端一次性发送多个请求（无需等待响应），但需注意队头阻塞（Head-of-Line Blocking）问题。

  **缺点：**
  + 资源占用：长期空闲的连接会占用服务器资源（如内存、端口），可能影响高并发场景的性能。
  + 队头阻塞（HTTP/1.1）：即使使用Keep-Alive，管道化请求仍可能因前一个请求处理慢而阻塞后续请求（HTTP/2通过多路复用解决此问题）。

  ##### 页面有多张图片，HTTP是怎样的加载表现？

  + 在HTTP 1下，浏览器对一个域名下最大TCP连接数为6，所以会请求多次。可以用多域名部署解决。这样可以提高同时请求的数目，加快页面图片的获取速度。
  + 在HTTP 2下，可以一瞬间加载出来很多资源，因为，HTTP2支持多路复用，可以在一个TCP连接中发送多个HTTP请求。

  ##### HTTP2的头部压缩算法是怎样的？

  **```HTTP2```** 的头部压缩是HPACK算法。在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。

  **具体来说:**

  + 在客户端和服务器端使用“首部表”，来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送；
  + 首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新；
  + 每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值。

  ##### HTTP请求报文的是什么样的？

  1. **请求⾏包括：** 请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET /index.html HTTP/1.1。

  2. **请求头部:** 请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔
    + User-Agent：产⽣请求的浏览器类型。
    + Accept：客户端可识别的内容类型列表。
    + Host：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机。

  3. **请求体:** post put等请求携带的数据

  [![image.png](https://i.postimg.cc/2StZPWk0/image.png)](https://postimg.cc/pmDrjpnj)

  ##### HTTP响应报文的是什么样的？
  + 响应⾏
  + 响应头
  + 空⾏
  + 响应体

  [![image.png](https://i.postimg.cc/13y82H10/image.png)](https://postimg.cc/GHS3sv29)

  ##### HTTP协议的优点和缺点

  **HTTP** 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。

  HTTP协议具有以下优点：

  + 支持客户端/服务器模式
  + **简单快速：** 客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。
  + **无连接：** 无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。
  + **无状态：** HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。
  + **灵活：** HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。

  HTTP协议具有以下缺点：

  + **无状态：** HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。
  + **明文传输：** 协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。
  + **不安全**

  ##### 说一下HTTP 3.0

  [![image.png](https://i.postimg.cc/mDW3c9Fm/image.png)](https://postimg.cc/WDSqCh8Z)

  HTTP/3基于**UDP**协议实现了类似于TCP的多路复用、数据流、传输可靠性等功能，这套功能被称为**QUIC**协议。

  1. **流量控制、传输可靠性功能：** QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些TCP中的特性。
  2. **集成TLS加密功能：** 目前QUIC使用TLS1.3，减少了握手所花费的RTT数。
  3. **多路复用：** 同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头阻塞问题。

  ##### HTTP协议的性能怎么样

  ##### URL有哪些组成部分

  ##### 与缓存相关的HTTP请求头有哪些

#### HTTPS协议

  ##### 什么是HTTPS协议？

  **HTTPS是超文本传输安全协议**（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，利用SSL/TLS来加密数据包。**HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。**

  [![image.png](https://i.postimg.cc/yN8xL8C7/image.png)](https://postimg.cc/hXNKjgGY)

  HTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议TLS/SSL具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生

  ##### TLS/SSL的工作原理

  **TLS/SSL全称安全传输层协议（Transport Layer Security）**, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。

  **TLS/SSL**的功能实现主要依赖三类基本算法：**散列函数hash、对称加密、非对称加密**。这三类算法的作用如下：

  + 基于**散列函数**验证信息的完整性
  + **对称加密算法**采用协商的秘钥对数据加密
  + **非对称加密**实现身份认证和秘钥协商

  [![image.png](https://i.postimg.cc/dV7Sbq4m/image.png)](https://postimg.cc/18QH6Zxf)

  1. **散列函数hash：** 常见的散列函数有 **MD5、SHA1、SHA256** 。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以用于防止信息篡改并验证数据的完整性。

  2. **对称加密：** 对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。常见的对称加密算法有AES-CBC、DES、3DES、AES-GCM等。相同的秘钥可以用于信息的加密和解密。掌握秘钥才能获取信息，防止信息窃听，其通讯方式是一对一。

  3. **非对称加密：** 非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。常见的非对称加密算法有RSA、ECC、DH等。非对称加密的**特点**就是**信息一对多**，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且**该算法的计算复杂，加密的速度慢。**

  总的来说：

  TLS/SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对称秘钥不同，从而保证信息只能通信双方获取。这样就解决了两个方法各自存在的问题。


  ##### 数字证书是什么？

  **前提：**
  现在的方法也不一定是安全的，因为没有办法确定得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而自己还不知道。为了解决这样的问题，可以使用数字证书。

  **解决方法**
  首先使用一种 Hash 算法来对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为**数字证书**。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。


  ##### HTTPS通信（握手）过程

  1. 客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。
  2. 服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。
  3. 客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。
  4. 服务器使用自己的私钥，来解密客户端发送过来的随机数。
  5. 客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。


#### HTTP状态码

  ##### 常见的状态码 

  [![image.png](https://i.postimg.cc/cH93G8xF/image.png)](https://postimg.cc/Q97CpCW7)

  ##### 2XX (Success 成功状态码)

  状态码2XX表示请求被正常处理了。

  + **200 OK**
    200 OK表示客户端发来的请求被服务器端正常处理了。

  + **204 No Content**
    该状态码表示客户端发送的请求已经在服务器端正常处理了，但是没有返回的内容，响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。

  + **206 Partial Content**
    该状态码表示客户端进行了范围请求，而服务器端执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。

  ##### 3XX (Redirection 重定向状态码)

  3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求

  + **301 Moved Permanently 永久重定向**

    该状态码表示请求的资源已经被分配了新的 URI，以后应使用资源指定的 URI。新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。若用户已经把原来的URI保存为书签，此时会按照 Location 中新的URI重新保存该书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。

    **使用场景：**

      + 当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。
      + 在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。
  
  + **302 Found 临时重定向**

    该状态码表示请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。和 301 Moved Permanently 状态码相似，但是 302 代表的资源不是被永久重定向，只是临时性质的。也就是说已移动的资源对应的 URI 将来还有可能发生改变。若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。

    **使用场景：**
    + 当我们在做活动时，登录到首页自动重定向，进入活动页面。
    + 未登陆的用户访问用户中心重定向到登录页面。
    + 访问404页面重新定向到首页。

  + **303 See Other**

    该状态码表示**由于请求对应的资源存在着另一个 URI**，应使用 GET 方法定向获取请求的资源。
    303 状态码和 302 Found 状态码有着相似的功能，但是 303 状态码明确表示客户端应当采用 GET 方法获取资源。
    303 状态码通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET。

  + **304 Not Modified 浏览器缓存相关**

    该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。
    带条件的请求（Http 条件请求）：使用 Get方法 请求，请求报文中包含（if-match、if-none-match、if-modified-since、if-unmodified-since、if-range）中任意首部。
  **状态码304并不是一种错误，而是告诉客户端有缓存，直接使用缓存中的数据**。返回页面的只有头部信息，是没有内容部分的，这样在一定程度上提高了网页的性能。

  + 307 **Temporary Redirect(临时重定向)**

    307表示临时重定向。该状态码与 302 Found 有着相同含义，尽管 302 标准禁止 POST 变成 GET，但是实际使用时还是这样做了。
    307 会遵守浏览器标准，不会从 POST 变成 GET。但是对于处理请求的行为时，不同浏览器还是会出现不同的情况。规范要求浏览器继续向 Location 的地址 POST 内容。规范要求浏览器继续向 Location 的地址 POST 内容。  

  ##### 4XX (Client Error 客户端错误状态码)

  + **400 Bad Request**

    该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。

  + **401 Unauthorized**

    该状态码表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息。若之前已进行过一次请求，则表示用户认证失败

    返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询(challenge)用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。

    **以下情况会出现401：**
    + 401.1 - 登录失败。
    + 401.2 - 服务器配置导致登录失败。
    + 401.3 - 由于 ACL 对资源的限制而未获得授权。
    + 401.4 - 筛选器授权失败。
    + 401.5 - ISAPI/CGI 应用程序授权失败。
    + 401.7 - 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。

  + **403 Forbidden**
    
    该状态码表明请求资源的访问被服务器拒绝了，服务器端没有必要给出详细理由，但是可以在响应报文实体的主体中进行说明。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关。

  + **404 Not Found**

    该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。

    以下情况会出现404：

    + 404.0 -（无） – 没有找到文件或目录。
    + 404.1 - 无法在所请求的端口上访问 Web 站点。
    + 404.2 - Web 服务扩展锁定策略阻止本请求。
    + 404.3 - MIME 映射策略阻止本请求。

  + 405 Method Not Allowed

    该状态码表示客户端请求的方法虽然能被服务器识别，但是服务器禁止使用该方法。GET 和 HEAD 方法，服务器应该总是允许客户端进行访问。客户端可以通过 OPTIONS 方法（预检）来查看服务器允许的访问方法, 如下
    ```
    Access-Control-Allow-Methods: GET,HEAD,PUT,PATCH,POST,DELETE
    ```

  ##### 5XX (Server Error 服务器错误状态码)

  + **500 Internal Server Error**

    该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。

  + **502 Bad Gateway**

    该状态码表明扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的。注意，502 错误通常不是客户端能够修复的，而是需要由途经的 Web 服务器或者代理服务器对其进行修复。以下情况会出现502：

    + 502.1 - CGI （通用网关接口）应用程序超时。
    + 502.2 - CGI （通用网关接口）应用程序出错。

  + **503 Service Unavailable**

    该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。
    使用场景：
    + 服务器停机维护时，主动用503响应请求；
    + nginx 设置限速，超过限速，会返回503。

  + **504 Gateway Timeout**

    该状态码表示网关或者代理的服务器无法在规定的时间内获得想要的响应。他是HTTP 1.1中新加入的。

    使用场景：代码执行时间超时，或者发生了死循环。


#### DNS协议

  ##### DNS协议是什么？

  DNS 是**域名系统 (Domain Name System)** 的缩写，主要的功能是提供的是一种主机名到 IP 地址的转换服务。它是一个由分层的 DNS 服务器组成的分布式数据库，**是定义了主机如何查询这个分布式数据库的方式的应用层协议**。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。

  **作用：** 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。

  ##### DNS完整的查询过程

  DNS服务器解析域名的过程：

  + 首先会在浏览器的缓存中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步
  + 将请求发送给本地DNS服务器，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步
  + 本地DNS服务器向根域名服务器发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址
  + 本地DNS服务器向顶级域名服务器发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址
  + 本地DNS服务器向权威域名服务器发送请求，域名服务器返回对应的结果
  + 本地DNS服务器将返回结果保存在缓存中，便于下次使用
  + 本地DNS服务器将返回结果返回给浏览器

  例如：
  如要查询 www.baidu.com 的 IP 地址，首先会在浏览器的缓存中查找是否有该域名的缓存，如果不存在就将请求发送到本地的 DNS 服务器中，本地DNS服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。

  ##### DNS同时使用TCP和UDP协议？

  ##### 迭代查询与递归查询

#### 网络模型

  1. OSI七层模型

  2. TCP/IP五层协议

  [![image.png](https://i.postimg.cc/7603mdyR/image.png)](https://postimg.cc/qhB67mqc)

#### TCP与UDP

  ##### TCP 和 UDP 的概念及特点

















