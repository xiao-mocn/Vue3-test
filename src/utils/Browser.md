#### 如何理解Cookie

**Cookie** 本质是一个由服务器创建、浏览器存储和管理的key-value形式的文本片段，主要作用是记录用户登录状态和浏览器行为跟踪。**Cookie** 的核心作用是让无状态的 HTTP 协议能够维持状态，http 本身是一种无状态协议，服务器无法单纯从网络协议层面判定用户身份。通常Cookie可以用过服务器 response 的 set-cookie 头下发或者也可以在 js 中写入（document.cookie = XXX）。因为Cookie保存着相关用户信息，所以Cookie合理使用和安全性很重要，一般我们需要注意：**1. 不要在 cookie 存储敏感信息 2. Cookie每次请求都会被携带，会有额外的开销，需要合理使用 3. 设置好时效，并强制启动 secure；建议启动 HttpOnly等**

**其他存储用户状态方法：**

**jwt：** 基本过程：用户登录后返回 token，浏览器存储在 localstorage 中，下次发送请求时通过 js 主动带上 token 数据，服务端解析 token 内容，验证、还原用户状态

  + 优点：
    + 服务端不需要存储用户登录态，天然的分布式认证方案，不需要 server 做任何信息存储，可用于分布式集群场景
    + 适配 app 等无 cookie 场景
    + 具有防篡改能力
    + 天然能预防 csrf 攻击

  + 缺点
    + 需要js 手动执行 token 的附加发送
    + 数据发散分布在用户端，服务器无法主动撤销 token 签发，这意味着不作额外处理时，jwt 下用户无法主动注销登录态

#### 全面理解浏览存储：Cookie vs LocalStroage vs SessionStroage vs IndexedDB

[![image.png](https://i.postimg.cc/d3kBLFKw/image.png)](https://postimg.cc/hQnx5Hj5)

**Cookie：**
作用：Cookie主要用于在客户端（浏览器）和服务器之间存储少量的数据，用于识别用户、实现会话状态管理和记录用户偏好等功能。
  + 优点：
    + 支持跨域访问。
    + 数据在浏览器和服务器之间传递。
  + 缺点：
    + 存储容量有限，通常最大为4KB。
    + 每次请求都会携带Cookie数据，增加网络流量。
    + 存储在Cookie中的数据可以被用户修改或删除。
    + 只能存储字符串类型的数据。

**LocalStorage：**
作用：LocalStorage是HTML5引入的机制，用于在浏览器端长期存储数据，供同一域名下的页面共享。
  + 优点：
    + 存储容量较大，通常为5MB或更大。
    + 数据存储在客户端，不会随每次请求发送到服务器。
    + 支持存储复杂的数据类型，如对象和数组。
  + 缺点：
    + 仅在同一域名下共享数据。
    + 数据存储在客户端，可能存在安全风险。
    + 无法跨域访问。

**SessionStorage：**
作用：SessionStorage与LocalStorage类似，但是数据在浏览器会话期间有效，关闭页面后数据会被清除。
  + 优点：
    + 存储容量较大，通常为5MB或更大。
    + 数据在浏览器会话期间有效，关闭页面后清除，适合存储临时数据。
    + 支持存储复杂的数据类型。
  + 缺点：
    + 仅在同一浏览器窗口或标签页中共享数据。
    + 无法跨域访问。

**IndexedDB：**
作用：IndexedDB是一个高级的客户端数据库系统，提供了异步操作和丰富的查询能力，用于在浏览器中存储大量结构化数据。
  + 优点：
    + 存储容量较大，通常为数百MB或更大。
    + 支持大规模、高性能的数据操作和查询。
    + 可以存储复杂的数据结构，支持事务。
  + 缺点：
    + 学习曲线较陡，API复杂。
    + 不同浏览器的兼容性存在差异。

#### 如何理解 iframe？ 有什么特点？一般应用在什么场景？

**```<iframe>标签```** 是在允许你将其他 Web 文档嵌入到当前文档中。每个 iframe 拥有自己的 ```window``` 对象和 ```document``` 对象，相当于一个沙盒环境，与父页面隔离（但可通过特定 API 通信）。常见的场景有：
1. **嵌入其他网页：** 最常见的使用方式是嵌入一个外部网页，让用户能够在当前页面中直接查看其他网站的内容。这可以在博客、新闻网站或电子商务网站中应用。
2. **集成第三方服务和组件：** 通过将第三方服务或组件嵌入到 iframe 中，可以实现功能的扩展和增强。例如，嵌入地图服务、支付系统或社交媒体的分享按钮等。
3. **广告展示：** 某些广告网络使用 iframe 来提供广告内容，以实现更好的隔离和可控性。这样可以确保广告不会影响到主页面的布局和性能。
4. **加载网页片段：** 有时候我们只需要加载并展示网页中的某个特定部分，而不是整个页面。通过使用 iframe 可以选择性地加载和渲染指定的网页片段。

通常iframe还存在一些特殊的用法：
+ **使用 iframe 进行跨域：** 使用 iframe 进行跨域请求的方式主要有两种：
  + 通过设置 document.domain  
  + 使用 HTML5 的跨域消息传递机制。
+ **文档预览：** 一些在线文档编辑器或云存储服务使用 iframe 来实现文档的预览功能。用户可以通过 iframe 在当前页面中查看文档的内容，而无需离开编辑器或云存储界面。

同时因为```iframe```是可以嵌入其他网页和其他资源，也可能存在一些安全隐患：
+ **跨域脚本攻击（Cross-Site Scripting, XSS）：** 如果在嵌入的网页中存在恶意脚本，这些脚本可以窃取用户数据、操纵页面内容或进行其他恶意操作。**使用 sandbox 属性**：该属性可以限制 iframe 内容的权限，防止恶意脚本的执行。
+ **点击劫持（Clickjacking）：** 攻击者可以利用 iframe 来创建一个看不见的透明层，覆盖在诱使用户点击的可见元素上，以达到欺骗和劫持用户点击的目的。**可以设置 X-Frame-Options HTTP 头：** 该头部可以阻止页面被嵌入到 iframe 中，提供一定的点击劫持保护。
+ **CSRF 攻击（Cross-Site Request Forgery）：** 在某些情况下，iframe 可以被用来诱使用户执行未经用户授权的操作，例如在用户登录了一个网站后，该网站又通过 iframe 嵌套了其他网站，并在该 iframe 页面中自动触发一些操作。**需要验证和过滤嵌入内容：** 在使用 iframe 嵌入第三方网页时，应该谨慎验证和过滤嵌入内容，确保只嵌入可信任的来源，并避免嵌入恶意或不受信任的内容。

#### 理解浏览器的多进程架构及渲染流程

  ##### 浏览器的五大进程

  + 浏览器进程： 负责界面显示、用户交互、子进程管理、提供储存等。
  + 渲染进程： 每个 tab 都有单独的渲染进程，核心用于渲染页面。
  + 网络进程： 主要处理网络资源加载（html、css、js等）。
  + GPU进程： 3D 绘制，提高性能。
  + 插件进程： Chrome 中安装的一些插件。

  通常，我们打包出来的 HTML、CSS、JavaScript 等文件，经过浏览器运行之后就会显示出页面，这个过程就是浏览器的渲染进程来操作实现的，渲染进程的主要任务就是**将静态资源转化为可视化界面**
  
  ***浏览器多进程的优势***
  + 相比于单进程浏览器，多进程有如下优点：
  + 避免单个page crash影响整个浏览器
  + 避免第三方插件crash影响整个浏览器
  + 多进程充分利用多核优势
  + 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性

  ##### 渲染进程详解

  浏览器的渲染进程是**多线程的**，可以这样理解，页面的渲染，JS的执行，事件的循环，都在这个进程内进行。

  [![image.png](https://i.postimg.cc/BbXQMnBF/image.png)](https://postimg.cc/H81gLHKW)

  1. **GUI渲染线程：**
      + 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
      + 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
      + 注意，**GUI渲染线程与JS引擎线程是互斥的**，当JS引擎执行时，GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。

  2. **JS引擎线程：**
      + 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）
      + JS引擎线程负责解析Javascript脚本，运行代码。
      + JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序
      + 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

  3. **事件触发线程**
      + 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
      + 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中
      + 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
      + 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）

  4. **定时触发器线程**
      + 传说中的setInterval与setTimeout所在线程
      + 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
      + 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
      + 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。

  5. **异步http请求线程**
      + 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
      + 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。

  ##### 首次渲染

  由于渲染机制比较复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的静态资源经过这些子阶段，最后输出页面。我们将一个处理流程称为渲染流水线，其大致流程如下图所示：

  [![image.png](https://i.postimg.cc/mrjL4HdM/image.png)](https://postimg.cc/hJJWbfRP)

  按我个人自己的理解：一般来说主要可以分为 *** Parse --> Render --> Composite ***

  大致的渲染流程如下：
  <!-- Parse -->
  1. 浏览器无法直接使用HTML，需要将HTML转化成DOM树（document）
  2. 浏览器无法解析纯文本的css样式，需要对css进行解析，解析成styleSheets（document.styleSheets）
  <!-- Render -->
  3. render Tree的生成 -> 计算出DOM树中每个节点的具体样式（Attachment），
  4. 创建渲染（布局）树，将DOM树中可见节点添加到布局树中。并计算节点渲染到页面的坐标位置（layout）
  5. 通过布局树进行分层（根据定位属性，透明属性，transform属性，clip属性等）生成图层树
  <!-- Composite --> 
  6. 将不同图层进行绘制，转交给合成线程处理。最终生成页面，并显示到浏览器上（painting,Display）

  对于这五个流程，每一阶段都有对应的产物，分别是：**DOM树、CSSOM树、渲染树、盒模型、界面**。

  渲染的各个模块详解：

  [![image.png](https://i.postimg.cc/FzMmpgRt/image.png)](https://postimg.cc/QKJRx71S)

  从图中可以看出，渲染引擎主要包含的模块有：
    + **HTML解析器：** 解析HTML文档，主要作用是将HTML文档转换成DOM树；
    + **CSS解析器：** 将DOM中的各个元素对象进行计算，获取样式信息，用于渲染树的构建；
    + **JavaScript解释器：** 使用JavaScript可以修改网页的内容、CSS规则等。JavaScript解释器能够解释JavaScript代码，并通过DOM接口和CSSOM接口来修改网页内容、样式规则，从而改变渲染结果；
    + **页面布局：** DOM创建之后，渲染引擎将其中的元素对象与样式规则进行结合，可以得到渲染树。布局则是针对渲染树，计算其各个元素的大小、位置等布局信息。
    + **页面绘制：** 使用图形库将布局计算后的渲染树绘制成可视化的图像结果。

  ##### 关键渲染路径

  理解关键渲染路径 -- **关键渲染路径。**
  关键渲染路径是**浏览器将 HTML，CSS 和 JavaScript 转换为屏幕上的像素所经历的步骤序列**。优化关键渲染路径可提高渲染性能。关键渲染路径包含了 文档对象模型(DOM)，CSS 对象模型 (CSSOM)，渲染树和布局。
  在解析 HTML 时会创建文档对象模型。HTML 可以请求 JavaScript，而 JavaScript 反过来，又可以更改 DOM。HTML 包含或请求样式，依次来构建 CSS 对象模型。浏览器引擎将两者结合起来以创建渲染树。布局确定页面上所有内容的大小和位置。确定布局后，将像素绘制到屏幕上。
  优化关键渲染路径可以缩短首次渲染的时间。了解和优化关键渲染路径对于确保重排和重绘可以每秒 60 帧的速度进行，以确保高效的用户交互并避免卡顿是很重要的。

  通常而言，关键渲染路径对应如下的渲染步骤图：

  [![image.png](https://i.postimg.cc/nrRTf0m5/image.png)](https://postimg.cc/4HcpzvBb)

  + JavaScript：一般来说，我们会使用 JavaScript 来实现一些视觉变化的效果。比如做一个动画或者往页面里添加一些 DOM 元素等。
  + Style：计算样式，这个过程是根据 CSS 选择器，对每个 DOM 元素匹配对应的 CSS 样式。这一步结束之后，就确定了每个 DOM 元素上该应用什么 CSS 样式规则。
  + Layout：布局，上一步确定了每个 DOM 元素的样式规则，这一步就是具体计算每个 DOM 元素最终在屏幕上显示的大小和位置。web 页面中元素的布局是相对的，因此一个元素的布局发生变化，会联动地引发其他元素的布局发生变化。比如， 元素的宽度的变化会影响其子元素的宽度，其子元素宽度的变化也会继续对其孙子元素产生影响。因此对于浏览器来说，布局过程是经常发生的。
  + Paint：绘制，本质上就是填充像素的过程。包括绘制文字、颜色、图像、边框和阴影等，也就是一个 DOM 元素所有的可视效果。一般来说，这个绘制过程是在多个层上完成的。
  + Composite：渲染层合并，由上一步可知，对页面中 DOM 元素的绘制是在多个层上进行的。在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。

  在页面性能优化的技巧中，大家一定听过，尽可能的减少页面的重绘和重排。
  上面的 Layout，也就是对应浏览器渲染过程中的重排的过程，而 Paint，对应的就是重绘的过程，而 Composite 就是最后的渲染层合并。
  对于页面的每一帧渲染（或者理解为动画渲染）其实也是一样，我们可以来看这么一张图：

  [![image.png](https://i.postimg.cc/8c6sTCfS/image.png)](https://postimg.cc/64BB0thj)

  我们把上面页面的每一帧渲染过程，想象成一个金字塔。而如果我们改变了底部的某些东西，金字塔就必须从底部开始重建。
  什么意思呢？在某一帧中，如果只有元素的 Paint，那么只需要经历 Paint --> Composite 的过程。
  而如果有元素的 Layout，则页面需要经历 Layout --> Paint --> Composite 的过程。
  而如果我们能寻找到只有 Composite 变换的渲染，则页面无需经历 Paint 和 Layout，此时页面是渲染性能就是最好的！
  因此，**我们想要高性能的 CSS 动画，也是需要尽可能的减少页面的重排与重绘！**


  [![image.png](https://i.postimg.cc/5Nzs6ch9/image.png)](https://postimg.cc/hfSL5Y4N)

  举个例子，我们想改变一个物体的显示与隐藏的切换，下面哪一种方式是更好的选择：

    + display: block 与 display: none 的切换
    + opacity: 0 与 opacity: 1 的切换

  对于 display: block 与 display: none 的切换，是会引起页面的重排（Layout），而 opacity 的变换，仅仅只会导致页面的 Composite（有一些浏览器可能是 Paint + Composite），因此，opacity 方案是更好的选择。


  **Layout：**
    + 生成每个元素的几何形状和位置
    + 非常消耗性能，因为渲染引擎必须重新考虑相关元素及其所有子元素后，才能计算新的布局
    + 当操作 DOM 树、影响布局的样式、更改浏览器窗口大小、ClassName 属性更改时会发生 Layout

  会触发 Layout 的 CSS 属性：
  [![image.png](https://i.postimg.cc/Dw21FtFM/image.png)](https://postimg.cc/JG2s5YsN)

  **Paint**
    + 将每个元素的像素绘制到不同的层中
    + 渲染引擎遍历所有元素以确定可见的内容和应显示的内容（十分消耗性能）
    + 绘制文字、添加轮廓（outline）、阴影（shadow）或更改背景颜色（background）
  会触发 Layout 的 CSS 属性：

  [![image.png](https://i.postimg.cc/Qd01M0dx/image.png)](https://postimg.cc/mP1tX390)

  **Composite：**
    + 只有不透明度（opacity）以及变换（transform）只触发 Composite
    + Blink 和 Webkit 内核为 CSS transform 和 opacity 创建了新的层（Graphics Layers）
    + translatez(0) 用于强制创建层（Graphics Layers），该层在动画启动后会立即进行绘制
    + 通过 The Web's Black Magic，了解 rendering 和 compositing 的最佳解释


#### 渲染合成层是什么？

  + 浏览器渲染时会将 dom、cssom 合并成 renderObject 树，之后按特定规则将 renderObject 树拆分为多个 render layer —— 渲染层，实现分层渲染(每一层都是 renderObject 树的一部分)
  + 分层渲染能大大优化渲染性能：
    + 不会因为局部小量更新导致全局重绘；
    + 部分特性可以只在渲染层执行重绘，例如 transform、opacity，不需要重排、重绘
  + 分层后，每一个 Render Layer 会生成一个独立渲染位图，浏览器需要按正确的顺序将其合并成一张图，绘制到屏幕上

  **浏览器渲染流程：**

  [![image.png](https://i.postimg.cc/rF6wSWPG/image.png)](https://postimg.cc/DmghhWFm)

  渲染过程大致可分为：**Network** => **Parse** => **Render(style, layout, paint, 有时候还有合成 -- compositing)** 阶段：

  **Parse**

  + html => dom tree
  + css => Style Rules(CSSOM)

  **Render**
  + **style：** 计算节点样式属性，生成 render Tree
    + DOM + CSSOM => RenderObject => Render Tree
    + Render Tree 中只包含需要渲染 or 布局的元素，如 display: none 或 script、head 等标签不会出现；但 visibility: hidden 会出现
  + **Layout：** 根据屏幕 viewport 与 render Object 的盒子属性，计算每一个 Render Object 节点的位置、宽高。注意：如果遇到无法计算宽高的节点(如图片)，会补充一个占位区域
  + **Paint：** 根据 layout 计算出的逻辑布局以及 render tree 的样式信息，计算各个节点的位图效果；这里为了提升渲染效率，会选择将渲染任务拆解成多个，形成 render Layer
    + 每一个触发分层的节点，以及该节点的子孙节点都划分为一个 render Layer；render Layer本身也会形成一颗树壮结构；
    ■
    + 触发分层(简单理解)：
      + document
      + video、canvas 标签
      + will-change、translateZ、opacity
      + index 比 renderlayer 层大的元素，会触发隐式合成层
      + chrome96 后对分层规则做了很多复杂的优化，不过大致上还是遵守上述逻辑
    + 为什么要切割：
      + 有利于改善频繁变更元素的渲染效果：video、canvas
      + 单层频繁变更不会影响其它层，能够减少全局重新布局、重绘的次数
      + 开启硬件加速后，可以以 render layer 为单位将部分计算任务发送到 GPU，实现硬件加速
      + 部分样式效果可以直接在 render layer 实现，不会触发重排、重绘，如：transform、opacity
    + 副作用：巨大的内存消耗，特别在过去有一种隐式合成层带来的所谓的“层爆炸”问题

  + **Composition：** 调用合成器线程(compositor)，将 render layer 按正确顺序合并成最终渲染效果
    + render layer 传递到 compositor 后，某些特殊的渲染层会被创建为合成层（Compositing Layers），这部分 layer 会被传递到 GPU 处理；只有下述情况下会创建独立 compositing layer
      + compositing layer 包含 3D 或 perspective transform CSS 属性；
      + 包含启动了加速解码功能的 video
      + 包含 3d 或 2d 加速 context 的canvas
      + 包含 transform 或 opacity 动画
      + 包含 css 滤镜
      + 父级 compositing layer
    + 接下来需要将多个 Compositing layer 合并成 GraphicsLayer
      + 由于 GraphicsLayer 占用一套完整的上下文接口和数据，占用内存较大，所以浏览器会尽量控制 GraphicsLayer 的数量
      + GraphicsLayer 之间也形成了树壮结构
      + GraphicsLayer 负责将合成层的位图合并在一起，并最终显示到界面上

#### 为什么浏览器要限制并发连接数？

  一般浏览器对并发连接数的限制是根据不同浏览器和版本而定的，浏览器限制并发连接数是为了**平衡网络资源的利用和提升用户体验**。以下是主要的原因：

  + **提高性能：** 浏览器在同一时间内发送多个并发请求有助于提高页面加载速度。但是，如果同时发送过多的请求，会对网络传输和服务器产生过大的负载，可能导致延迟和拥塞。
  + **控制带宽消耗：** 每个并发连接都需要占用一定的带宽资源。如果浏览器不进行限制，用户访问网页时可能出现大量并发连接，造成网络带宽耗尽。
  + 计算机资源有限，且线程切换成本很高，不可能无限制创建 tcp 连接
  + 许多服务器为了防御 ddos 攻击，其实也会限制同一ip过来的连接数，超过会主动关闭
  + 一种平衡策略，防止多个客户端竞争有限资源，导致马太效应

#### 为什么浏览器会出现白屏？

白屏一般是指页面因为某些原因导致崩溃，无法正常渲染内容的现象。通常来说主要的原因是1. 关键静态资源异常、2.js未捕获异常、3.死循环、4.运行时 bug这几类原因。

白屏主要还分为

  + 纯白屏：可以理解为一整个页面从刷新进入后一直处于白屏阶段，无任何响应，无 Loading 出现
  + Loading 白屏、或骨架屏白屏：初始化阶段出现阻塞异常（前端核心JS资源加载失败、API请求失败后的未捕获的异常、JS解析过程的抛出异常等）都会造成这类白屏。可能已经出现了类似 Loading 等页面加载动画。
  + 局部元素缺失的白屏：当具体页面渲染过程中，出现阻塞元素渲染的异常，比如数据异常、关键资源加载异常等、导致元素的关键配置信息无法构建完成，则会出现局部元素缺失的白屏

**如何预防：代码健壮性**
  + 不要相信上游数据(接口、函数参数、上下文状态、store 等等)，做好必要的输入数据检测
  + try-catch：同步、异步(async-await) 均可，可以放在容易出错的可疑区域(如 JSON.parse)
  + 捕获未知异常，并主动上报：
  + 跨域脚本做好跨域处理
  + 补充必要的单元测试，特别是边界值、非法值测试
  + 关注 npm 包的 breaking change

**检测方案：**

+ serviceWorker检测
+ load + beforeUnload，load 的时候在storage 记个状态，如果没有unload就证明crash了
+ 各种基于 DOM 的衍生检测方案（检测DOM层级、换算成分数）
+ 采样检测界面中的元素是否为白屏态元素

  
#### 如何理解 Websocket

  WebSocket 是HTML5后引入的，是一种在单个 TCP 连接上提供**全双工（Full-Duplex）、双向通信通道的网络通信协议**。它通过基于 HTTP 的握手建立连接，复用 http 协议，借助 101 响应码实现协议升级，切换到轻量级的二进制帧协议进行全双工数据传输，即它允许客户端（通常是 Web 浏览器）和服务器之间建立持久连接，使得数据可以在连接打开的任何时刻，以非常低的延迟，从任意一端高效地推送到另一端。主要存在持久连接、低延迟、轻量级数据帧、全双工通信等特点，可用于开发聊天、协作、游戏、实时数据监控等应用。

#### 如何理解 preload 指令

  用于预加载资源的 html 指令，相当于告诉浏览器：我在当前页面马上要用到这个资源，需要你尽快帮我加载回来。网页中有非常多外联资源，js、css、图片等等，使用前总需要先等待资源的下载，如果我们能做到预先加载资源，那在资源执行的时候就不必等待网络的开销

  **用法：**
  ```html
  <link rel="preload" 
  href="https://example.com/fonts/font.woff" 
  as="font" 
  crossorigin 
  onload="handleOnload()" 
  onerror="handlepreloadError()"/>
  <!-- 
  href: 资源地址
  as：声明资源的类型，支持大多数常见文件类型；不同类型有不同优先级
  crossorigin：声明是否跨域
  onload：加载成功时触发
  onerror：加载失败时触发
   -->
  ```

  需要注意的是：
  + **作用：**
    + 借助 preload，开发者可以明确声明需要预加载的资源列表
    + 资源被 preload 后，会被首先放入浏览器缓存
  + **实践：**
    + 对 preload 使用 “as” 属性，否则浏览器无法识别资源类型，可能导致二次加载(预加载失效)
    + 对跨域资源表明 crossorigin，否则同样导致二次加载(http 请求的 header 不同)
  + **问题：** preload 的资源不一定都被用到，可能造成无效的预加载，在移动端下需要特别注意

#### 如何理解浏览器的缓存体系

  一般来说浏览器中可以按照一定缓存策略，将网络资源存储到本地，下次再次请求时直接使用本地副本，避免二次加载，主要作用是缓存机制节省网络时间与流量。

  **浏览器缓存的全过程：**

  + 浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；

  + 下一次加载资源时，由于**强制缓存优先级较高**，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 **cache-control 设置的 max-age**，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则使用 **expires 头**判断是否过期；

  + 如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 **If-None-Match 和 If-Modified-Since 的请求**；

  + 服务器收到请求后，**优先根据 Etag 的值判断被请求的文件有没有做修改**，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；

  + **如果服务器收到的请求没有 Etag 值**，则将 **If-Modified-Since 和被请求文件的最后修改时间做比对**，一致则命中协商缓存，返回 304；不一致则返回新的 last-Modified 和文件并返回 200；

  [![image.png](https://i.postimg.cc/cLRgKT18/image.png)](https://postimg.cc/75LYd32x)

  很多网站的资源后面都加了版本号，这样做的目的是：每次升级了 JS 或 CSS 文件后，为了防止浏览器进行缓存，强制改变版本号，客户端浏览器就会重新下载新的 JS 或 CSS 文件 ，以保证用户能够及时获得网站的最新更新。

  此外，浏览器实现上会将不同内容缓存到不同位置：

  + 内存缓存：直接将内容存储在内存中，效率非常高，可以实现 0ms 响应，但容量很少；
  + ServiceWorker 实现缓存：若没有命中内存缓存，浏览器会尝试使用 ServiceWorker；可用于自定义缓存策略，响应时间大概在 10ms 量级，容量相对较大；
  + 硬盘缓存：若未命中 ServiceWorker 逻辑，则尝试使用硬盘缓存，响应时间大概 10ms 量级，容量最大；

#### 如何理解 requestAnimationFrame 接口

  **```requestAnimationFrame```** （简称 RAF）是浏览器提供的用于执行高效动画的 JavaScript API，它能确保动画与屏幕刷新率同步，实现流畅渲染。

  通常浏览器以帧（任务流）为单位，循环调度任务，我们通常称之为渲染流水线，
  + **事件处理：** 浏览器首先需要处理用户交互事件，比如点击，滚动，输入等等。这一步会触发 JS 代码的运行；
  + **触发 RAF**
  + **解析 CSS 生成 CSSOM 树：** 同时，浏览器还解析外部和内部的 CSS 信息，生成 CSSOM 树。
  + **构造 Render 树：** 根据 DOM 树和 CSSOM 树构造 Render 树。 Render 树是包含颜色和高度宽度等属性以及它们对应的元素和内容的树形结构，它在 DOM 树和 CSSOM 树的基础上，删去了那些不需要进行显示的部分，比如 head 标签或者 display：none 的元素。
  + **布局：** 布局阶段是根据构建的布局树来确定元素在设备视口（viewport）内的确切位置和大小，通常我们称这个阶段为"重排"。
  + **绘制：** 绘制阶段是将布局树中的每个节点转换为屏幕上的实际像素，我们通常把这个阶段称为"重绘"。
  + **合成：** 由于一些效果（如滚动，动画等）可能导致部分区域需要重新绘制，绘制后的元素会被分成不同的层，然后由 GPU 进行合成（Compositing）, 最后将最终图像渲染到屏幕上。
  + 触发 **requestIdleCallback** (如果有空的话，有空的判定是： 16ms - 当前帧执行耗时>0)

  也就是说我们在RAF的回调中去执行修改 dom、样式等，这些改动在接下来的渲染环节生效，可以保证也浏览器刷新频率一致。总的来说 **```requestAnimationFrame```** 能显著提升前端动画性能和用户体验



#### 如何理解 GPU 渲染加速？什么是合成层 CompositeLayers

  例如：当我们使用 ```transform``` 和 ```opacity``` 对元素进行动画时，浏览会尝试优化这段动画。浏览器将所有内容作为纹理（texture）传输到 GPU，而不是对每一帧上的像素进行光栅化。GPU 非常擅长执行此类基于纹理的转换，因此，我们得到了非常流畅、高性能的动画，这称为“硬件加速”。

  简单来说，浏览器为了提升动画的性能，为了在动画的每一帧的过程中不必每次都重新绘制整个页面。在特定方式下可以触发生成一个合成层（Composite Layers），合成层拥有单独的 GraphicsLayer。而通过生成独立的 GraphicsLayer，让此层内的重绘重排不引起整个页面的重绘重排，这就是CSS 3D 硬件加速的最本质的原因。

  一般来说硬件加速存在两种方式
  1. transform: translateZ(0)
  2. will-change: transform;

#### 前端需要掌握的浏览器安全知识

  ##### 同源策略（跨域限制）

  同源策略是一个重要的安全策略，它用于限制一个源的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。

  一般来说如果两个 URL 的 **协议、端口（如果有指定的话）和主机** 都相同的话，则这两个 URL 是同源的。因为同源策略控制不同源之间的交互，所以想要访问其他资源可能会存在跨域问题。常有的跨域方法：
  ●
  + 1.jsonp
  + **2.CORS**
  + 3.postMessage
  + 4.websocket
  + **5.Node中间件代理(两次跨域)**
  + 6.nginx反向代理
  + 7.window.name + iframe
  + 8.location.hash + iframe
  + 9.document.domain + iframe

  一般来说现实中我们常使用的就是**CROS和Node中间件代理(两次跨域)**

  **预检请求：**

  预检请求是在进行跨域资源共享 CORS 时，由浏览器自动发起的一种 OPTIONS 请求。它的存在是为了保障安全，并允许服务器决定是否允许跨域请求。合理的使用预检请求机制可以有效地防范跨域请求带来的安全风险，保护用户数据和隐私。

  ##### 什么是跨站脚本攻击（XSS）

  **Cross-Site Scripting（跨站脚本攻击）**简称 XSS，是一种**代码注入攻击**。攻击者通过在目标网站上注入恶意脚本，恶意代码未经过滤，与网站正常的代码混在一起，浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。攻击者利用这些恶意脚本，可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。

  ###### XSS主要存在几种类型：

  1. **存储型**
  2. **反射型**
  3. **DOM 型**

  **存储型：**

  存储型 XSS 的攻击步骤：

  1. **攻击者将恶意代码提交到目标网站的数据库中**。
  2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，**拼接在 HTML 中返回给浏览器**。
  3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
  4. **恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。**

  这种攻击常见于带有用户保存数据的网站功能，**如论坛发帖、商品评论、用户私信**等。

  **反射型：**

  反射型 XSS 的攻击步骤：

  1. **攻击者构造出特殊的 URL，其中包含恶意代码。**
  2. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
  3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
  4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

  反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等.
  反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。

  **DOM 型 XSS**

  DOM 型 XSS 的攻击步骤：

  1. **攻击者构造出特殊的 URL**，其中包含恶意代码。
  2. 用户打开带有恶意代码的 URL。
  3. 用户浏览器接收到响应后解析执行，**前端 JavaScript 取出 URL 中的恶意代码并执行。**
  4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

  DOM 型 XSS 跟前两种 XSS 的区别：**DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。**

  ###### XSS的防御

  总的来说，XSS攻击主要是分为了 1.服务器存在漏洞 2.JS前端出现漏洞，但整体的 XSS 防范是非常复杂和繁琐的，很难通过技术手段完全避免 XSS，但我们可以尽量减少漏洞的产生：

  + **利用模板引擎：** 开启模板引擎自带的 HTML 转义功能，做好HTML的转义功能。
  + **避免拼接 HTML：** 前端采用拼接 HTML 的方法比较危险，在使用过程中需要注意。
  + **增加攻击难度，降低攻击后果：** 通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。
  + **避免内联事件：** 尽量不要使用 ```onLoad="onload('{{data}}')"、onClick="go('{{action}}')"``` 这种拼接内联事件的写法。在 JavaScript 中通过 ```.addEventlistener()``` 事件绑定会更安全。
  + **主动检测和发现:** 可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。

  ##### 什么是跨站请求伪造攻击（CSRF）

  ###### 什么是 CSRF？

  **CSRF（Cross-site request forgery）跨站请求伪造**：攻击者诱导受害者进入**第三方网站**，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，**达到冒充用户对被攻击的网站执行某项操作的目的**。

  ###### CSRF 的几种分类

  + **GET 类型的 CSRF:**
    GET类型的CSRF利用非常简单，只需要一个HTTP请求，一般会这样利用：
    ```html
    <img src="http://bank.example/withdraw?amount=10000&for=hacker" >
    ```
    在受害者访问含有这个img的页面后，浏览器会自动向 ```http://bank.example/withdraw?account=xiaoming&amount=10000&for=hacker``` 发出一次HTTP请求。bank.example就会收到包含受害者登录信息的一次跨域请求

  + **POST 类型的 CSRF:**

  这种类型的CSRF利用起来通常使用的是一个自动提交的表单，如：

  访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。

  POST 类型的攻击通常比 GET 要求更加严格一点，但仍并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许 POST 上面。

  + **链接类型的 CSRF**

    链接类型的CSRF并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，例如：

    由于之前用户登录了信任的网站A，并且保存登录状态，只要用户主动访问上面的这个PHP页面，则表示攻击成功。


  ###### CSRF的防御

  CSRF 总结

  简单总结一下上文的防护策略：

  + CSRF 自动防御策略：同源检测（Origin 和 Referer 验证）。
  + CSRF 主动防御措施：Token 验证或者双重 Cookie 验证 以及配合 Samesite Cookie。
  + 保证页面的幂等性，后端接口不要在 GET 页面中做用户操作。

  为了更好的防御 CSRF，最佳实践应该是结合上面总结的防御措施方式中的优缺点来综合考虑，结合当前 Web 应用程序自身的情况做合适的选择，才能更好的预防 CSRF 的发生。


  ##### 什么是内容安全策略（CSP）

  内容安全策略（CSP）是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本（XSS）和数据注入攻击等。简单来说，CSP 的作用是：开发者明确告诉客户端（制定比较严格的策略和规则），哪些外部资源是可以加载和执行的 ，即使攻击者发现漏洞，但是它是没办法注入脚本的。CSP可以由两种方式指定： HTTP Header 和 HTML。

  + 通过定义在 HTTP header 中定义使用：
  ```js
  "Content-Security-Policy:" 策略集
  ```
  + 通过定义在 HTML meta标签中使用：
  ```html
  <meta http-equiv="content-security-policy" content="策略集">
  ```

  ##### 浏览器的安全沙箱策略 ?

#### 精讲：优化资源交付( 优化的概念--> 后续项目继续深入)





